# block queue

阻塞任务队列，这里一个线程安全的队列，用于存放任务 task. 是对 queue 的简单包装


## TODO
- [ ] mutex
- [ ] condition_variable


mutable， 修饰成员变量时，可以在const修饰的成员函数函数内被改变


## 学习
### 子类不能直接访问父类的private成员变量和方法
子类不能直接访问父类的private成员变量和方法，必须通过this指针来访问
### C++使用虚函数的时候，子类也要使用virtual关键字吗?
   c++规定，当一个成员函数被声明为虚函数后，其派生类中的同名函数都自动成为虚函数。因此，在子类从新声明该虚函数时，可以加，也可以不加，但习惯上每一层声明函数时都加virtual,使程序更加清晰。
### 重载、覆盖、隐藏
a.成员函数被重载的特征：

（1）相同的范围（在同一个类中）；

（2）函数名字相同；

（3）参数不同；

（4）virtual 关键字可有可无。

b.覆盖是指派生类函数覆盖基类函数，特征是：

（1）不同的范围（分别位于派生类与基类）；

（2）函数名字相同；

（3）参数相同；

（4）基类函数必须有virtual 关键字。

c.“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：

（1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。

（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）


### c++ 子类构造函数初始化及父类构造初始化
https://blog.csdn.net/sevenjoin/article/details/82222895

构造函数与父类的其它成员(成员变量和成员方法)不同，它不能被子类继承。因此，在创建子类对象时，为了初始化从父类中继承来的成员变量，编译器需要调用其父类的构造函数。如果子类的构造函数没有显示地调用父类的构造函数，则默认调用父类的无参构造函数，至于什么事显式调用，在下面会详细说明！关于子类中构造函数的构造原则，总结如下，欢迎大家指导与批评。

1.父类没有声明构造函数
(1)子类也没有声明自己的构造函数，则父类和子类均由编译器生成默认的构造函数。
(2)子类中声明了构造函数(无参或者带参)，则子类的构造函数可以写成任何形式，不用顾忌父类的构造函数。在创建子类对象时，先调用父类默认的构造函数(编译器自动生成)，再调用子类的构造函数。

2.父类只声明了无参构造函数
如果子类的构造函数没有显式地调用父类的构造，则将会调用父类的无参构造函数。也就是说，父类的无参构造函数将会被隐式地调用。

3.父类只声明了带参构造函数
在这种情况下，要特别注意。因为父类只有带参的构造函数，所以如果子类中的构造函数没有显示地调用父类的带参构造函数，则会报错，所以必需显示地调用。
加上一个冒号(:)，然后加上父类的带参构造函数，这就是父类构造函数的显式调用。这样，在子类的构造函数被调用时，系统就会去调用父类的带参构造函数，从而实现初始化父类的成员变量
如果父类只有带参的构造函数，且该带参的构造函数的参数有默认值，此时在子类中也可以不用显示的调用父类的构造函数。

4.父类同时声明了无参和带参构造函数
在这种情况下，子类只需要实现父类的一个构造函数即可，不管是无参的还是带参的构造函数。如果子类的构造函数没有显示地调用父类的构造函数(无参或带参)，则默认调用父类的无参构造函数。

### 成员变量std::mutex要用mutable修饰。
mutable的作用是突破const的限制，使得一个成员函数在const修饰的时候，依然可以更改mutable修饰的成员变量。因为成员变量mutex_，会不断地加锁解锁，所以互斥元必须是可变的。

###   C++11新关键字default，delete
仅创建了有参构造函数后，如果你想调用无参构造函数编译是会报错的。因为一旦你自己定义了构造函数，系统的默认构造函数是被屏蔽的，也就是说此时是没有无参构造函数的，所以我们需要自己定义一个无参构造函数。但是现在在C++11中，如果我们仅定义了有参构造函数，可以通过default关键字让默认构造函数恢复
https://vra.github.io/2016/01/17/default-deleted/